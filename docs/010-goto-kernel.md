用精炼一点的话总结的话就是分两步走：

    1. 写了一段32位的代码，然后编译成elf32的.o，并在这段代码中调用c的一个函数
    2. 写一段c的代码也编译成.o，包含汇编中调用的那个函数的函数体
    3. 最终把汇编和c语言链接到一起，成为bin文件，写到硬盘中就算ok了（当然这段代码要在loader中加载到内存中）

因此我们发现，比较关键的地方就是，怎么在汇编中调用c的函数， 并成功把两个重定位文件链接到一起，因此在up的视频中也可以看到，大部分时间都是在写新的makefile

---

1. asm 编译到 .o

        nasm -f win32 $< -o $@

    其中 -f win32 是编译到 32位的意思, 编译后 可以用 nm 命令 查看.o文件的符号表：

                λ nm -a ..\superbigouis2\build\kernel\start.o
                00000000 t .text
                00000000 T _start
                00000000 a src/kernel/start.asm

    这里一个简单的理解就是 "T" 符号意味着 数据在当前的文件中


    还可以使用 objdemp / readelf 查看.o文件的更多信息, 内容有点多， 先略过

    objdump 的话 使用 -x 参数 可以显示最多的内容

    这里在用nasm 编译完发现链接不起来，分别查看符号表，发现本来c文件中的函数名字没有以下划线开头，编译出的.o却带着下划线，
    因此还需要把asm中的函数加上下划线，才能正确链接起来


2. start.o  和 main.o 链接成 kernel.bin

        ld -m i386pe -static $^ -o $@ -Ttext $(ENTRY_POINT)

    + 这里的 static 指的是 把所有的能链接的全部链接成静态文件，据说会导致文件体积膨胀

    + -Ttext 则是指定了 代码段 .text的首地址， 有点类似 nasm 中的 org 的作用
